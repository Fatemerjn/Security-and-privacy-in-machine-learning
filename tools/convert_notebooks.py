"""
Utility for exporting project notebooks to plain Python modules.

The converter strips notebook-specific magics (``!`` shell commands and ``%``
line magics) and removes ``get_ipython`` helper calls so that the resulting
modules run as regular Python scripts.

Usage:
    python tools/convert_notebooks.py
"""

from __future__ import annotations

import argparse
import textwrap
from pathlib import Path
from typing import Dict

import nbformat


REPO_ROOT = Path(__file__).resolve().parents[1]
NOTEBOOK_DIR = REPO_ROOT / "notebooks"
SRC_DIR = REPO_ROOT / "src"

# Mapping between notebook filenames and the target module paths.
NOTEBOOK_MAP: Dict[str, Path] = {
    "adversarial_attacks_and_defenses.ipynb": SRC_DIR
    / "adversarial"
    / "adversarial_attacks_and_defenses.py",
    "data_poisoning_attacks.ipynb": SRC_DIR
    / "poisoning"
    / "data_poisoning_attacks.py",
    "differential_privacy_mechanisms.ipynb": SRC_DIR
    / "differential_privacy"
    / "differential_privacy_mechanisms.py",
    "membership_inference_attacks.ipynb": SRC_DIR
    / "membership_inference"
    / "membership_inference_attacks.py",
    "model_extraction_attacks.ipynb": SRC_DIR
    / "model_extraction"
    / "model_extraction_attacks.py",
    "neural_networks_from_scratch.ipynb": SRC_DIR
    / "neural_networks"
    / "neural_networks_from_scratch.py",
}


MAGIC_PREFIXES = ("!", "%")
MAGIC_SUBSTRINGS = ("get_ipython()",)


def clean_source(source: str) -> str:
    """Remove notebook-only constructs from a code cell."""
    cleaned_lines = []
    for raw_line in source.splitlines():
        stripped = raw_line.strip()
        if not stripped:
            cleaned_lines.append("")
            continue
        if stripped.startswith(MAGIC_PREFIXES):
            continue
        if any(token in raw_line for token in MAGIC_SUBSTRINGS):
            continue
        cleaned_lines.append(raw_line.rstrip())
    # Trim leading/trailing blank lines that remain after filtering.
    while cleaned_lines and not cleaned_lines[0]:
        cleaned_lines.pop(0)
    while cleaned_lines and not cleaned_lines[-1]:
        cleaned_lines.pop()
    return "\n".join(cleaned_lines)


def convert_notebook(notebook_name: str, target_path: Path) -> None:
    """Convert a single notebook to a Python module."""
    nb_path = NOTEBOOK_DIR / notebook_name
    if not nb_path.exists():
        raise FileNotFoundError(f"Notebook not found: {nb_path}")

    nb = nbformat.read(nb_path, as_version=4)
    code_blocks = []
    for cell in nb.cells:
        if cell.get("cell_type") != "code":
            continue
        cleaned = clean_source("".join(cell.get("source", [])))
        if cleaned:
            code_blocks.append(cleaned)

    header = textwrap.dedent(
        f'''\
        """
        Auto-generated from notebooks/{notebook_name}.

        Generated by tools/convert_notebooks.py. Do not edit manually.
        """
        '''
    ).strip("\n")

    if code_blocks:
        indented_blocks = [textwrap.indent(block, "    ") for block in code_blocks]
        body = "\n\n\n".join(indented_blocks)
    else:
        body = "    pass"

    module_source = (
        f"{header}\n\n\n"
        "def main():\n"
        f"{body}\n\n\n"
        "if __name__ == \"__main__\":\n"
        "    main()\n"
    )

    target_path.parent.mkdir(parents=True, exist_ok=True)
    target_path.write_text(module_source, encoding="utf-8")


def main(selected: str | None = None) -> None:
    """CLI entrypoint."""
    if selected:
        targets = {selected: NOTEBOOK_MAP[selected]}
    else:
        targets = NOTEBOOK_MAP

    for notebook, target in targets.items():
        convert_notebook(notebook, target)
        rel_target = target.relative_to(REPO_ROOT)
        print(f"[export] {notebook} -> {rel_target}")


if __name__ == "__main__":
    parser = argparse.ArgumentParser(description="Export notebooks to Python modules.")
    parser.add_argument(
        "--notebook",
        choices=sorted(NOTEBOOK_MAP.keys()),
        help="Export only the specified notebook.",
    )
    args = parser.parse_args()
    main(args.notebook)
